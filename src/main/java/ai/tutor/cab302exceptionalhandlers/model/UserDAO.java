package ai.tutor.cab302exceptionalhandlers.model;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/**
 * Manages {@code User} entities.
 * <p>
 * This Data Access Object (DAO) provides methods to perform CRUD operations on the
 * {@code users} table in the SQLite database. Users are identified by a unique ID and
 * username, with a stored password hash, supporting authentication and user management
 * within the application.
 *
 * @author Jack
 */

public class UserDAO implements IUserDAO {
    private final Connection connection;

    /**
     * Initialises the {@code UserDAO} with an SQLite database connection.
     * <p>
     * This constructor establishes a connection using the provided {@code SQLiteConnection}
     * and creates the {@code users} table if it does not exist. The table includes an
     * auto-incrementing primary key for the user ID, a unique username, and a password hash.
     *
     * @param sqliteConnection the {@code SQLiteConnection} instance for database access
     * @throws SQLException if a database error occurs during initialisation
     * @throws RuntimeException if the SQLite connection cannot be established
     */

    public UserDAO(SQLiteConnection sqliteConnection) throws SQLException, RuntimeException {
        connection = sqliteConnection.getInstance();
        createTable();
    }

    /**
     * Creates the {@code users} table in the SQLite database.
     * <p>
     * This method defines the schema for the {@code users} table, including columns for
     * an auto-incrementing user ID, a unique username, and a password hash. The table
     * enforces uniqueness on the username to prevent duplicate user accounts.
     *
     * @throws SQLException if a database error occurs during table creation
     */

    private void createTable() throws SQLException {
        try (Statement createTable = connection.createStatement()) {
            createTable.execute(
                    "CREATE TABLE IF NOT EXISTS users ("
                    + "id INTEGER PRIMARY KEY AUTOINCREMENT,"
                    + "username VARCHAR UNIQUE NOT NULL,"
                    + "password VARCHAR NOT NULL"
                    + ")"
            );
        }
    }


    /**
     * Saves a new {@code User} entity to the database.
     * <p>
     * This method inserts a {@code User} entity into the {@code users} table, storing
     * its username and password hash. The user ID is automatically generated by the
     * SQLite database and set on the {@code User} entity to ensure uniqueness.
     *
     * @param user the {@code User} entity to save
     * @throws SQLException if a database error occurs during insertion
     */

    @Override
    public void createUser(User user) throws SQLException {
        String sql = "INSERT INTO users (username, password) VALUES (?, ?)";
        try (PreparedStatement createUser = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            createUser.setString(1, user.getUsername());
            createUser.setString(2, user.getPasswordHash());
            createUser.executeUpdate();

            try (ResultSet generatedKeys = createUser.getGeneratedKeys()) {
                if (generatedKeys.next()) {
                    user.setId(generatedKeys.getInt(1));
                }
            }
        }
    }

    /**
     * Updates an existing {@code User} entity in the database.
     * <p>
     * This method updates the username and password hash of a {@code User} entity in the
     * {@code users} table, identified by the user’s ID.
     *
     * @param user the {@code User} entity to update
     * @throws SQLException if a database error occurs during update
     */

    @Override
    public void updateUser(User user) throws SQLException {
        String sql = "UPDATE users SET username = ?, password = ? WHERE id = ?";
        try (PreparedStatement updateUser = connection.prepareStatement(sql)) {
            updateUser.setString(1, user.getUsername());
            updateUser.setString(2, user.getPasswordHash());
            updateUser.setInt(3, user.getId());
            updateUser.executeUpdate();
        }
    }

    /**
     * Deletes a {@code User} entity from the database.
     * <p>
     * This method removes a {@code User} entity from the {@code users} table identified by
     * the user’s ID. Cascading deletions in the {@code chats} and {@code messages} tables, handled
     * by foreign key constraints.
     *
     * @param user the {@code User} entity to delete
     * @throws SQLException if a database error occurs during deletion
     */

    @Override
    public void deleteUser(User user) throws SQLException {
        String sql = "DELETE FROM users WHERE id = ?";
        try (PreparedStatement deleteUser = connection.prepareStatement(sql)) {
            deleteUser.setInt(1, user.getId());
            deleteUser.executeUpdate();
        }
    }

    /**
     * Retrieves a {@code User} entity by its ID.
     * <p>
     * This method fetches a single {@code User} entity from the {@code users} table that
     * matches the specified ID. Returns {@code null} if no user is found for the given ID.
     *
     * @param id the ID of the user
     * @return the {@code User} entity, or {@code null} if none exists
     * @throws IllegalArgumentException if {@code id} is negative
     * @throws SQLException if a database error occurs during retrieval
     */

    @Override
    public User getUser(int id) throws IllegalArgumentException, SQLException {
        String sql = "SELECT * FROM users WHERE id = ?";
        try (PreparedStatement readUser = connection.prepareStatement(sql)) {
            readUser.setInt(1, id);
            ResultSet resultSet = readUser.executeQuery();

            if (resultSet.next()) {
                String username = resultSet.getString("username");
                String password = resultSet.getString("password");
                User user = new User(username, password);
                user.setId(id);
                return user;
            }
        }
        return null;
    }

    /**
     * Retrieves a {@code User} entity by its username.
     * <p>
     * This method fetches a single {@code User} entity from the {@code users} table that
     * matches the specified username. Returns {@code null} if no user is found for the
     * given username.
     *
     * @param username the username of the user
     * @return the {@code User} entity, or {@code null} if none exists
     * @throws IllegalArgumentException if {@code username} is {@code null} or empty
     * @throws SQLException if a database error occurs during retrieval
     */

    @Override
    public User getUser(String username) throws IllegalArgumentException, SQLException {
        String sql = "SELECT * FROM users WHERE username = ?";
        try (PreparedStatement readUser = connection.prepareStatement(sql)) {
            readUser.setString(1, username);
            ResultSet resultSet = readUser.executeQuery();

            if (resultSet.next()) {
                int id = resultSet.getInt("id");
                String password = resultSet.getString("password");
                User user = new User(username, password);
                user.setId(id);
                return user;
            }
        }
        return null;
    }

    /**
     * Retrieves all {@code User} entities from the database.
     * <p>
     * This method fetches all users from the {@code users} table. Returns a list of
     * {@code User} entities, which may be empty if no users are found.
     *
     * @return a {@code List} of {@code User} entities, or an empty list if none exist
     * @throws SQLException if a database error occurs during retrieval
     */

    @Override
    public List<User> getAllUsers() throws SQLException {
        List<User> users = new ArrayList<>();
        try (Statement readUsers = connection.createStatement()) {
            ResultSet resultSet = readUsers.executeQuery(
                    "SELECT * FROM users"
            );

            while (resultSet.next()) {
                int id = resultSet.getInt("id");
                String username = resultSet.getString("username");
                String password = resultSet.getString("password");
                User user = new User(username, password);
                user.setId(id);
                users.add(user);
            }
        }
        return users;
    }
}
